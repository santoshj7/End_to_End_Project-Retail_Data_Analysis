CREATE DATABASE RETAILS;
USE RETAILS;

/* TABLE CREATION */

CREATE OR REPLACE TABLE DEMOGRAPHIC_RAW (
    AGE_DESC VARCHAR(10),
    MARITAL_STATUS_CODE VARCHAR(5),
    INCOME_DESC VARCHAR(20),
    HOMEOWNER_DESC VARCHAR(25),
    HH_COMP_DESC VARCHAR(40),
    HOUSEHOLD_SIZE_DESC VARCHAR(15),
    KID_CATEGORY_DESC VARCHAR(15),
    household_key INT PRIMARY KEY
);

CREATE OR REPLACE TABLE CAMPAIGN_DESC_RAW (
    DESCRIPTION VARCHAR(15),
    CAMPAIGN INT,
    START_DAY INT,
    END_DAY INT,
    PRIMARY KEY (DESCRIPTION),  
    UNIQUE (CAMPAIGN)
);
-- Snowflake doesn't enforce the primary key. Hence, in the above code, we shouldn't take a composite primary key as we did in the MySQL Workbench script. Instead, we should take one column as the primary key and another as the unique key.


CREATE OR REPLACE TABLE CAMPAIGN_RAW (
    DESCRIPTION VARCHAR(15),
    household_key INT,
    CAMPAIGN INT,
    FOREIGN KEY (DESCRIPTION) REFERENCES CAMPAIGN_DESC_RAW(DESCRIPTION),
    FOREIGN KEY (CAMPAIGN) REFERENCES CAMPAIGN_DESC_RAW(CAMPAIGN),
    FOREIGN KEY (household_key) REFERENCES DEMOGRAPHIC_RAW(household_key)
);

CREATE OR REPLACE TABLE PRODUCT_RAW (
    PRODUCT_ID INT PRIMARY KEY,
    MANUFACTURER INT,
    DEPARTMENT VARCHAR(50),
    BRAND VARCHAR(15),
    COMMODITY_DESC VARCHAR(100),
    SUB_COMMODITY_DESC VARCHAR(100),
    CURR_SIZE_OF_PRODUCT VARCHAR(20)
);

CREATE OR REPLACE TABLE COUPON_RAW (
    COUPON_UPC INT,
    PRODUCT_ID INT,
    CAMPAIGN INT,
    FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCT_RAW(PRODUCT_ID),
    FOREIGN KEY (CAMPAIGN) REFERENCES CAMPAIGN_DESC_RAW(CAMPAIGN)
);

CREATE OR REPLACE TABLE COUPON_REDEMPT_RAW (
    household_key INT,
    DAY INT,
    COUPON_UPC INT,
    CAMPAIGN INT,
    FOREIGN KEY (household_key) REFERENCES DEMOGRAPHIC_RAW(household_key),
    FOREIGN KEY (CAMPAIGN) REFERENCES CAMPAIGN_DESC_RAW(CAMPAIGN)
);

CREATE OR REPLACE TABLE TRANSACTION_RAW (
    HOUSEHOLD_KEY INT,
    BASKET_ID INT,
    DAY INT,
    PRODUCT_ID INT,
    QUANTITY INT,
    SALES_VALUE FLOAT,
    STORE_ID INT,
    RETAIL_DISC FLOAT,
    TRANS_TIME INT,
    WEEK_NO INT,
    COUPON_DISC INT,
    COUPON_MATCH_DISC INT,
    FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCT_RAW(PRODUCT_ID),
    FOREIGN KEY (HOUSEHOLD_KEY) REFERENCES DEMOGRAPHIC_RAW(household_key)
);

------------------------------------------------------------------------------------------

/* AWS S3 STORAGE INTEGRATION */

-- Create all the necessary roles and policies in AWS before performing storage integration.

-- Now, create the S3 Storage Integration in Snowflake and map the S3 user (Role) to it.

CREATE OR REPLACE STORAGE INTEGRATION S3_RETAILDATA_RAW_INT
TYPE = EXTERNAL_STAGE
STORAGE_PROVIDER = S3
ENABLED = TRUE
STORAGE_AWS_ROLE_ARN = 'arn:aws:iam::211125340148:role/retailrole'  -- Enter Role ARN
STORAGE_ALLOWED_LOCATIONS = ('s3://retaildata.raw/');  -- Enter S3 bucket name with path

DESC INTEGRATION S3_RETAILDATA_RAW_INT;

-- Now, update the Trust Relationship Policy in the AWS IAM role's Trust Relationship section with the 'STORAGE_AWS_IAM_USER_ARN' obtained from the DESC INTEGRATION command in the previous step.

-- Create a file format in Snowflake, which will be required during the 'Stage' creation process.
-- You can directly run the file format command in the worksheet to create a file format, or alternatively, you can create it by opening the RETAILS database details in a new tab.

-- Now, create an external (S3) stage that references the storage integration created previously.

CREATE OR REPLACE STAGE RETAIL_STAGE
URL ='s3://retaildata.raw'    -- S3 bucket name
FILE_FORMAT = RETAIL_CSV     -- File Format name we created previously
STORAGE_INTEGRATION = S3_RETAILDATA_RAW_INT;

-- Upon successful creation of the stage, list the stage. 
-- When we list a stage, we view its directory to see all uploaded files in S3 bucket, verifying successful creation and contents.

LIST @RETAIL_STAGE;

SHOW STAGES;

-- Now, create an auto-ingest pipe, i.e., Snowpipe, which recognizes CSV files ingested from the external stage and copies the data into the existing table in Snowflake.
-- Ensure that the number of Snowpipes created matches the number of folders (tables) in the S3 bucket. This guarantees that each pipe is attached to its respective folder in the bucket.
-- The AUTO_INGEST = TRUE parameter specifies to read event notifications sent from an S3 bucket to an SQS queue when new data is ready to load.

CREATE OR REPLACE PIPE RETAIL_SNOWPIPE_CAMPAIGN_DESC 
AUTO_INGEST = TRUE AS
COPY INTO RETAILS.PUBLIC.CAMPAIGN_DESC_RAW -- Respective table path in Snowflake
FROM '@RETAIL_STAGE/CAMPAIGN_DESC/' -- Stage name & S3 bucket subfolder name
FILE_FORMAT = RETAIL_CSV; -- File Format name

CREATE OR REPLACE PIPE RETAIL_SNOWPIPE_CAMPAIGN 
AUTO_INGEST = TRUE AS
COPY INTO RETAILS.PUBLIC.CAMPAIGN_RAW 
FROM '@RETAIL_STAGE/CAMPAIGN/' 
FILE_FORMAT = RETAIL_CSV; 

CREATE OR REPLACE PIPE RETAIL_SNOWPIPE_COUPON_REDEMPT 
AUTO_INGEST = TRUE AS
COPY INTO RETAILS.PUBLIC.COUPON_REDEMPT_RAW 
FROM '@RETAIL_STAGE/COUPON_REDEMPT/' 
FILE_FORMAT = RETAIL_CSV; 

CREATE OR REPLACE PIPE RETAIL_SNOWPIPE_COUPON 
AUTO_INGEST = TRUE AS
COPY INTO RETAILS.PUBLIC.COUPON_RAW 
FROM '@RETAIL_STAGE/COUPON/' 
FILE_FORMAT = RETAIL_CSV; 

CREATE OR REPLACE PIPE RETAIL_SNOWPIPE_DEMOGRAPHIC 
AUTO_INGEST = TRUE AS
COPY INTO RETAILS.PUBLIC.DEMOGRAPHIC_RAW 
FROM '@RETAIL_STAGE/DEMOGRAPHIC/' 
FILE_FORMAT = RETAIL_CSV; 

CREATE OR REPLACE PIPE RETAIL_SNOWPIPE_PRODUCT 
AUTO_INGEST = TRUE AS
COPY INTO RETAILS.PUBLIC.PRODUCT_RAW 
FROM '@RETAIL_STAGE/PRODUCT/' 
FILE_FORMAT = RETAIL_CSV;

CREATE OR REPLACE PIPE RETAIL_SNOWPIPE_TRANSACTION 
AUTO_INGEST = TRUE AS
COPY INTO RETAILS.PUBLIC.TRANSACTION_RAW 
FROM '@RETAIL_STAGE/TRANSACTION/' 
FILE_FORMAT = RETAIL_CSV;

SHOW PIPES;

-- After creating Snowpipe, obtain the ‘Notification Channel’ value by running the command ‘SHOW PIPES’. 
-- Now, create an Event Notification in S3 bucket using 'Notification Channel arn' which is available in the above Snowpipes, to read event notifications sent from an S3 bucket to an SQS queue when new data is ready to load.

-- By using the code below, we can check if any new data is updated in our S3 bucket. It is not mandatory to refresh the pipe every time; it is only for the user's purpose to ensure that all the pipe connections are successful and data is flowing from the S3 bucket to the Snowflake table.

ALTER PIPE RETAIL_SNOWPIPE_CAMPAIGN_DESC REFRESH;
ALTER PIPE RETAIL_SNOWPIPE_CAMPAIGN REFRESH;
ALTER PIPE RETAIL_SNOWPIPE_COUPON_REDEMPT REFRESH;
ALTER PIPE RETAIL_SNOWPIPE_COUPON REFRESH;
ALTER PIPE RETAIL_SNOWPIPE_DEMOGRAPHIC REFRESH;
ALTER PIPE RETAIL_SNOWPIPE_PRODUCT REFRESH;
ALTER PIPE RETAIL_SNOWPIPE_TRANSACTION REFRESH;

-- We can see that all the data from the S3 bucket has been successfully copied into the respective Snowflake tables.

SELECT * FROM CAMPAIGN_DESC_RAW;
SELECT * FROM CAMPAIGN_RAW;
SELECT * FROM COUPON_RAW;
SELECT * FROM COUPON_REDEMPT_RAW;
SELECT * FROM DEMOGRAPHIC_RAW;
SELECT * FROM PRODUCT_RAW;
SELECT * FROM TRANSACTION_RAW;
SELECT COUNT(*) FROM TRANSACTION_RAW; -- 450416  (count of rows before updating new records)
-- 1162359 after loading new data

-----------------------------------------------------------------------------

/* DATA CLEANING AND TRANSFORMATION */

-- The raw data has been successfully copied from the S3 bucket. As the next step, the data needs to be reviewed and cleaned to ensure it is suitable for analysis.
-- Python has been selected as the programming language for data transformation and cleaning in this project. To proceed, it is necessary to establish a connection between Snowflake and Python.

-- Cleaned and transformed data from Python

SELECT * FROM CAMPAIGN_DESC_NEW;
SELECT * FROM COUPON_REDEMPT_NEW;
SELECT * FROM TRANSACTION_NEW;

SELECT * FROM TRANSACTION_NEW 
WHERE DATE BETWEEN '2023-01-01' AND '2023-06-30';

SELECT * FROM TRANSACTION_NEW 
WHERE DATE BETWEEN '2023-07-01' AND '2023-12-31';

SELECT * FROM TRANSACTION_NEW 
WHERE DATE BETWEEN '2024-01-01' AND '2024-06-30';

SELECT * FROM TRANSACTION_NEW 
WHERE DATE BETWEEN '2024-07-01' AND '2024-12-31';
------------------------------------------------------------------------------------

/* AD-HOC KPI ANALYSIS */

-- I. CUSTOMER DEMOGRAPHICS KPIS:

SELECT * FROM DEMOGRAPHIC_RAW;

-- 1. Count of unique Households: Measure the total number of unique households in the Demographic table.

SELECT COUNT(DISTINCT HOUSEHOLD_KEY) AS TOTAL_HOUSEHOLDS
FROM DEMOGRAPHIC_RAW;  -- 2500

-- 2. Household Composition Distribution: Analyze the distribution of household compositions (HH_COMP_DESC) to understand the composition of households.

SELECT HH_COMP_DESC, COUNT(DISTINCT HOUSEHOLD_KEY) AS TOTAL_HOUSEHOLDS
FROM DEMOGRAPHIC_RAW
GROUP BY 1
ORDER BY 2 DESC;

-- 3. Age Distribution: Calculate the percentage or count of customers in different age groups (AGE_DESC).

SELECT *, ROUND((TOTAL_HOUSEHOLDS / 2500) * 100, 2) AS AGEWISE_HOUSEHOLDS_DISTR_PERC
FROM
(SELECT AGE_DESC, COUNT(DISTINCT HOUSEHOLD_KEY) AS TOTAL_HOUSEHOLDS,
FROM DEMOGRAPHIC_RAW
GROUP BY 1
ORDER BY 2 DESC);

-- 4. Marital Status Distribution: Analyze the proportion of customers in different marital status categories (MARITAL_STATUS_CODE). 

SELECT MARITAL_STATUS_CODE, COUNT(DISTINCT HOUSEHOLD_KEY) AS TOTAL_HOUSEHOLDS,
ROUND(COUNT(DISTINCT HOUSEHOLD_KEY) / 2500 * 100, 2) AS MARITAL_HOUSEHOLDS_DISTR_PERC
FROM DEMOGRAPHIC_RAW
GROUP BY 1
ORDER BY 2 DESC;

-- 5. Income Distribution: Determine the distribution of customers across income levels (INCOME_DESC). 

SELECT INCOME_DESC, COUNT(DISTINCT HOUSEHOLD_KEY) AS TOTAL_HOUSEHOLDS,
ROUND(COUNT(DISTINCT HOUSEHOLD_KEY) / 2500 * 100, 2) AS INCOMEWISE_HOUSEHOLDS_DISTR_PERC
FROM DEMOGRAPHIC_RAW
GROUP BY 1
ORDER BY 2 DESC;

-- 6. Homeownership Distribution: Calculate the percentage or count of customers who own or rent their homes (HOMEOWNER_DESC).

SELECT HOMEOWNER_DESC, COUNT(DISTINCT HOUSEHOLD_KEY) AS TOTAL_HOUSEHOLDS,
ROUND(COUNT(DISTINCT HOUSEHOLD_KEY) / 2500 * 100, 2) AS HOMEOWNER_HOUSEHOLDS_DISTR_PERC
FROM DEMOGRAPHIC_RAW
GROUP BY 1
ORDER BY 2 DESC;

-- 7. Household Composition Distribution:

SELECT HH_COMP_DESC, KID_CATEGORY_DESC, HOUSEHOLD_SIZE_DESC AS TOT_HOUSEHOLD_SIZE_DESC,
COUNT(DISTINCT HOUSEHOLD_KEY) AS TOTAL_HOUSEHOLDS,
ROUND(COUNT(DISTINCT HOUSEHOLD_KEY) / 2500 * 100, 2) AS HOUSEHOLDS_COMP_DISTR_PERC
FROM DEMOGRAPHIC_RAW
GROUP BY 1,2,3
ORDER BY 4 DESC;

-- HOUSEHOLD_KPI

SELECT T.HOUSEHOLD_KEY, D.AGE_DESC, D.MARITAL_STATUS_CODE, D.INCOME_DESC, D.HOMEOWNER_DESC, 
D.HOUSEHOLD_SIZE_DESC, D.HH_COMP_DESC, D.KID_CATEGORY_DESC, 
COUNT(DISTINCT T.BASKET_ID) AS TOT_BASKET_OR_TXN_COUNT,
AVG(T.QUANTITY) AS AVG_BASKET_SIZE,
SUM(T.QUANTITY) AS TOT_BASKET_SIZE,
MAX(T.DATE) - MIN(T.DATE) AS CUSTOMER_TENURE,
AVG(T.SALES_VALUE) AS AVG_SALES_AMOUNT,
SUM(T.SALES_VALUE) AS TOT_SALES_AMOUNT,
AVG(ABS(T.RETAIL_DISC)) AS AVG_RETAIL_DISC, 
AVG(ABS(T.COUPON_DISC)) AS AVG_COUPON_DISC, 
AVG(ABS(T.COUPON_MATCH_DISC)) AS AVG_COUPON_MATCH_DISC,
SUM(ABS(T.RETAIL_DISC)) AS TOT_RETAIL_DISC,
SUM(ABS(T.COUPON_DISC)) AS TOT_COUPON_DISC,
SUM(ABS(T.COUPON_MATCH_DISC)) AS TOT_COUPON_MATCH_DISC,
AVG(ABS(T.RETAIL_DISC) + ABS(T.COUPON_DISC) + ABS(T.COUPON_MATCH_DISC)) AS OVERALL_AVG_DISCOUNT,
SUM(ABS(T.RETAIL_DISC) + ABS(T.COUPON_DISC) + ABS(T.COUPON_MATCH_DISC)) AS TOT_DISCOUNT,
ROUND(SUM(ABS(T.RETAIL_DISC) + ABS(T.COUPON_DISC) + ABS(T.COUPON_MATCH_DISC)) / NULLIF(SUM(T.SALES_VALUE), 0) * 100, 2) AS TOT_DISCOUNT_PERC,
AVG(T.SALES_VALUE + T.RETAIL_DISC + T.COUPON_DISC + T.COUPON_MATCH_DISC) AS AVG_NET_SALES_AMOUNT,
SUM(T.SALES_VALUE + T.RETAIL_DISC + T.COUPON_DISC + T.COUPON_MATCH_DISC) AS TOT_NET_SALES_AMOUNT
FROM TRANSACTION_NEW AS T
LEFT OUTER JOIN DEMOGRAPHIC_RAW AS D ON T.HOUSEHOLD_KEY = D.HOUSEHOLD_KEY
GROUP BY 1,2,3,4,5,6,7,8
ORDER BY 1;

SELECT COUNT(DISTINCT BASKET_ID), COUNT(DISTINCT HOUSEHOLD_KEY),
COUNT( BASKET_ID), COUNT( HOUSEHOLD_KEY)
FROM TRANSACTION_NEW;

SELECT * FROM TRANSACTION_NEW
WHERE HOUSEHOLD_KEY IN (1480, 1846) ;

-- II. CAMPAIGN KPIS:

SELECT * FROM CAMPAIGN_RAW LIMIT 10;
SELECT * FROM CAMPAIGN_DESC_NEW;

-- 1. Number of Campaigns: Count the total number of campaigns in the Campaign table.

SELECT COUNT(DISTINCT CAMPAIGN) AS TOT_CAMPAIGNS
FROM CAMPAIGN_RAW;   -- 30

-- 2. Number of Households Participating in Campaigns: Count the total number of households that participated in the campaigns.

SELECT COUNT(DISTINCT HOUSEHOLD_KEY) AS TOT_HOUSEHOLDS
FROM CAMPAIGN_RAW;   -- 1584

-- 3. Number of Campaigns: Count the total number of campaigns based on their description in the Campaign table.

SELECT DESCRIPTION, COUNT(DISTINCT CAMPAIGN) AS TOT_CAMPAIGNS
FROM CAMPAIGN_RAW 
GROUP BY 1
ORDER BY 1;

-- 4. Campaign Duration: Calculate the duration of each campaign by subtracting the start day from the end day (in the Campaign_desc table).

SELECT CAMPAIGN, DATEDIFF(DAY, START_DATE, END_DATE) AS CAMPAIGN_DURATION
FROM CAMPAIGN_DESC_NEW
ORDER BY 2 DESC;

-- 5. Campaign Effectiveness: Analyse the number of households associated with each campaign (in the Campaign table) to measure campaign reach.

SELECT C.CAMPAIGN, CD.CAMPAIGN_DURATION, COUNT(C.HOUSEHOLD_KEY) AS TOT_HOUSEHOLDS_PARTICIPATED,
ROUND(COUNT(DISTINCT C.HOUSEHOLD_KEY) / (SELECT COUNT(DISTINCT HOUSEHOLD_KEY) FROM CAMPAIGN_RAW) * 100, 2) AS HOUSEHOLDS_PARTICIPATION_PERC
FROM CAMPAIGN_RAW AS C
LEFT OUTER JOIN CAMPAIGN_DESC_NEW AS CD ON C.CAMPAIGN = CD.CAMPAIGN
GROUP BY 1,2
ORDER BY 3 DESC;

-- 6. Households Participation in Campaigns

SELECT HOUSEHOLD_KEY, COUNT(DISTINCT CAMPAIGN) AS TOT_PARTICIPATED_CAMPAIGNS,
ROUND(COUNT(DISTINCT CAMPAIGN) / (SELECT COUNT(DISTINCT CAMPAIGN) FROM CAMPAIGN_RAW) * 100, 2) AS CAMPAIGN_PARTICIPATION_PERC
FROM CAMPAIGN_RAW
GROUP BY 1
ORDER BY 2 DESC;

-- CAMPAIGN_KPI

WITH CAMPAIGN_PARTICIPATION AS (
    SELECT HOUSEHOLD_KEY, CAMPAIGN, COUNT(CAMPAIGN) OVER (PARTITION BY HOUSEHOLD_KEY) AS CAMPAIGN_COUNT
    FROM CAMPAIGN_RAW
)
SELECT C.CAMPAIGN, C.DESCRIPTION, CD.START_DATE AS CAMPAIGN_START_DATE, 
CD.END_DATE AS CAMPAIGN_END_DATE, CD.CAMPAIGN_DURATION,
COUNT(DISTINCT C.HOUSEHOLD_KEY) AS TOT_HOUSEHOLDS,
ROUND((COUNT(DISTINCT C.HOUSEHOLD_KEY)) / (SELECT COUNT(DISTINCT HOUSEHOLD_KEY) FROM CAMPAIGN_RAW) * 100, 2) AS HOUSEHOLD_ENGAGEMENT_RATE,
SUM(CASE WHEN CP.CAMPAIGN_COUNT = 1 THEN 1 ELSE 0 END) AS SINGLE_CAMPAIGN_HOUSEHOLDS_COUNT,
SUM(CASE WHEN CP.CAMPAIGN_COUNT > 1 THEN 1 ELSE 0 END) AS MULTIPLE_CAMPAIGN_HOUSEHOLDS_COUNT,
ROUND(SUM(CASE WHEN CP.CAMPAIGN_COUNT = 1 THEN 1 ELSE 0 END) / COUNT(DISTINCT C.HOUSEHOLD_KEY) * 100,2) AS SINGLE_CAMPAIGN_ENGAGEMENT_RATE,
ROUND(SUM(CASE WHEN CP.CAMPAIGN_COUNT > 1 THEN 1 ELSE 0 END) / COUNT(DISTINCT C.HOUSEHOLD_KEY) * 100,2) AS MULTIPLE_CAMPAIGN_ENGAGEMENT_RATE

FROM CAMPAIGN_RAW AS C
LEFT OUTER JOIN CAMPAIGN_DESC_NEW AS CD ON C.CAMPAIGN = CD.CAMPAIGN
LEFT OUTER JOIN CAMPAIGN_PARTICIPATION AS CP ON C.HOUSEHOLD_KEY = CP.HOUSEHOLD_KEY AND C.CAMPAIGN = CP.CAMPAIGN
GROUP BY 1,2,3,4,5
ORDER BY 1;


-- III. COUPON KPIS:

SELECT * FROM COUPON_RAW LIMIT 20;
SELECT * FROM COUPON_REDEMPT_NEW LIMIT 20;

-- 1. Number of Coupons: Count the total number of coupons distributed in the coupon table.

SELECT COUNT(DISTINCT COUPON_UPC) AS TOT_UNIQUE_COUPONS_ISSUED 
FROM COUPON_RAW;   -- 1135

SELECT COUNT(COUPON_UPC) AS TOT_COUPONS_ISSUED 
FROM COUPON_RAW;   -- 124548

-- 2. Number of Coupons Used: Count the total number of coupons redeemed.

SELECT COUNT(DISTINCT COUPON_UPC) AS TOT_UNIQUE_COUPONS_REDEEMED 
FROM COUPON_REDEMPT_NEW;   -- 556

SELECT COUNT(COUPON_UPC) AS TOT_COUPONS_REDEEMED 
FROM COUPON_REDEMPT_NEW;  -- 2318

-- 3. Coupon Redemption Rate: Calculate the percentage of coupons redeemed (from the coupon_redempt table) compared to the total number of coupons distributed (from the Coupon table).

SELECT COUNT(DISTINCT CO.COUPON_UPC) AS TOT_UNIQUE_COUPONS_ISSUED, 
COUNT(DISTINCT COR.COUPON_UPC) AS TOT_UNIQUE_COUPONS_REDEEMED,
ROUND(COUNT(DISTINCT COR.COUPON_UPC) / COUNT(DISTINCT CO.COUPON_UPC) * 100, 2) AS COUPON_REDEMPTION_RATE
FROM COUPON_RAW AS CO
LEFT OUTER JOIN COUPON_REDEMPT_NEW AS COR ON CO.COUPON_UPC = COR.COUPON_UPC AND CO.CAMPAIGN = COR.CAMPAIGN;

-- 4. Coupon usage by campaign: Measure the number of coupon redemptions (from the coupon_redempt table) for each campaign (in the Coupon table).

SELECT CO.CAMPAIGN, COUNT(DISTINCT CO.COUPON_UPC) AS TOT_COUPONS_DISTRIBUTED,
COUNT(DISTINCT COR.COUPON_UPC) AS TOT_COUPONS_REDEEMED,
ROUND(COUNT(DISTINCT COR.COUPON_UPC) / COUNT(DISTINCT CO.COUPON_UPC) * 100, 2) AS COUPON_REDEMPTION_RATE
FROM COUPON_RAW AS CO
LEFT OUTER JOIN COUPON_REDEMPT_NEW AS COR ON CO.COUPON_UPC = COR.COUPON_UPC AND CO.CAMPAIGN = COR.CAMPAIGN
GROUP BY 1
ORDER BY 3 DESC;

SELECT CO.CAMPAIGN, COUNT(DISTINCT CO.PRODUCT_ID) AS DISTINCT_PRODUCT_COUNT, 
COUNT(DISTINCT CO.COUPON_UPC) AS TOT_UNIQUE_COUPONS_DISTRIBUTED,
COUNT(DISTINCT COR.COUPON_UPC) AS TOT_UNIQUE_COUPONS_REDEEMED,
ROUND(COUNT(DISTINCT COR.COUPON_UPC) / COUNT(DISTINCT CO.COUPON_UPC) * 100, 2) AS REDEMPTION_RATE,
COUNT(CO.COUPON_UPC) AS TOT_COUPONS_DISTRIBUTED,
COUNT(COR.COUPON_UPC) AS TOT_COUPONS_REDEEMED,
FROM COUPON_RAW AS CO
LEFT OUTER JOIN COUPON_REDEMPT_NEW AS COR ON CO.COUPON_UPC = COR.COUPON_UPC AND CO.CAMPAIGN = COR.CAMPAIGN
GROUP BY 1
ORDER BY 1;

-- 5. Count of distinct products associated with each campaign

SELECT COUNT(DISTINCT PRODUCT_ID) AS DISTINCT_PRODUCT_COUNT
FROM COUPON_RAW;   -- 44133

SELECT CAMPAIGN, COUNT(DISTINCT PRODUCT_ID) AS DISTINCT_PRODUCT_COUNT
FROM COUPON_RAW 
GROUP BY 1;

-- 6. Top Redeemed Products by Campaign

SELECT CO.PRODUCT_ID, COR.CAMPAIGN, 
COUNT(DISTINCT COR.COUPON_UPC) AS TOTAL_REDEMPTIONS
FROM COUPON_RAW AS CO 
LEFT OUTER JOIN COUPON_REDEMPT_NEW AS COR ON CO.COUPON_UPC = COR.COUPON_UPC AND CO.CAMPAIGN = COR.CAMPAIGN
GROUP BY 1,2
ORDER BY 3 DESC;

-- 7. Redemption Rate per Product

SELECT CO.PRODUCT_ID, COUNT(DISTINCT CO.COUPON_UPC) AS TOT_COUPONS_DISTRIBUTED,
COUNT(DISTINCT COR.COUPON_UPC) AS TOT_COUPONS_REDEEMED,
ROUND(COUNT(DISTINCT COR.COUPON_UPC) / COUNT(DISTINCT CO.COUPON_UPC) * 100, 2) AS REDEMPTION_RATE_PER_PRODUCT
FROM COUPON_RAW AS CO
LEFT OUTER JOIN COUPON_REDEMPT_NEW AS COR ON CO.COUPON_UPC = COR.COUPON_UPC AND CO.CAMPAIGN = COR.CAMPAIGN
GROUP BY 1
ORDER BY 2 DESC,3 DESC;

-- 8. Top Redeeming Households

SELECT HOUSEHOLD_KEY, COUNT(DISTINCT COUPON_UPC) AS TOT_COUPONS_REDEEMED
FROM COUPON_REDEMPT_NEW
GROUP BY 1
ORDER BY 2 DESC;

SELECT CAMPAIGN, COUNT(COUPON_UPC) AS TOT_COUPONS_REDEEMED,
COUNT(DISTINCT HOUSEHOLD_KEY) AS TOTAL_HOUSEHOLDS_REDEEMING,
ROUND(COUNT(COUPON_UPC) / COUNT(DISTINCT HOUSEHOLD_KEY), 2) AS AVG_COUPONS_REDEEMED_PER_HOUSEHOLD
FROM COUPON_REDEMPT_NEW
GROUP BY 1
ORDER BY 2 DESC;

-- 9. Day of Week Redemption Analysis

SELECT DAYOFWEEK(DATE) AS DAY_OF_WEEK, DAYNAME(DATE) AS DAY_NAME, 
COUNT(DISTINCT COUPON_UPC) AS TOT_UNIQUE_COUPONS_REDEEMED, 
COUNT(COUPON_UPC) AS TOT_COUPONS_REDEEMED
FROM COUPON_REDEMPT_NEW
GROUP BY 1,2
ORDER BY 3 DESC, 4 DESC;

-- 10. Redemption Peak Periods (e.g., weekly, monthly, yearly)

SELECT DATE_TRUNC('WEEK', DATE) AS WEEK,
COUNT(DISTINCT COUPON_UPC) AS TOT_UNIQUE_COUPONS_REDEEMED, 
COUNT(COUPON_UPC) AS TOT_COUPONS_REDEEMED
FROM COUPON_REDEMPT_NEW
GROUP BY 1
ORDER BY 3 DESC;

SELECT DATE_TRUNC('MONTH', DATE) AS MONTH,
COUNT(DISTINCT COUPON_UPC) AS TOT_UNIQUE_COUPONS_REDEEMED, 
COUNT(COUPON_UPC) AS TOT_COUPONS_REDEEMED
FROM COUPON_REDEMPT_NEW
GROUP BY 1
ORDER BY 3 DESC;

SELECT DATE_TRUNC('YEAR', DATE) AS YEAR,
COUNT(DISTINCT COUPON_UPC) AS TOT_UNIQUE_COUPONS_REDEEMED, 
COUNT(COUPON_UPC) AS TOT_COUPONS_REDEEMED
FROM COUPON_REDEMPT_NEW
GROUP BY 1
ORDER BY 3 DESC;

-- Coupon Redemptions Over Time (Daily Trend) & Campaign

SELECT DATE, CAMPAIGN,
COUNT(DISTINCT COUPON_UPC) AS TOT_UNIQUE_COUPONS_REDEEMED,
COUNT(COUPON_UPC) AS TOT_COUPONS_REDEEMED
FROM COUPON_REDEMPT_NEW
GROUP BY 1,2
ORDER BY 4 DESC;

-- COUPON_KPI

SELECT CO.CAMPAIGN, -- COR.DATE AS COUPON_REDEMPTION_DATE,
COUNT(DISTINCT CO.PRODUCT_ID) AS DISTINCT_PRODUCT_COUNT,
COUNT(DISTINCT CO.COUPON_UPC) AS TOT_COUPONS_DISTRIBUTED,
COUNT(DISTINCT COR.COUPON_UPC) AS TOT_COUPONS_REDEEMED,
ROUND(COUNT(DISTINCT COR.COUPON_UPC) / COUNT(DISTINCT CO.COUPON_UPC) * 100, 2) AS COUPON_REDEMPTION_RATE,
COUNT(DISTINCT COR.HOUSEHOLD_KEY) AS UNIQUE_REDEEMERS_HOUSEHOLDS_COUNT
FROM COUPON_RAW AS CO
LEFT OUTER JOIN COUPON_REDEMPT_NEW AS COR ON CO.COUPON_UPC = COR.COUPON_UPC AND CO.CAMPAIGN = COR.CAMPAIGN
GROUP BY 1
ORDER BY 1;

-- Joining both CAMPAIGN_KPI and COUPON_KPI

SELECT CA.CAMPAIGN, CA.DESCRIPTION, CA.CAMPAIGN_START_DATE, CA.CAMPAIGN_END_DATE, CA.CAMPAIGN_DURATION, CO.DISTINCT_PRODUCT_COUNT, CA.TOT_HOUSEHOLDS, CA.HOUSEHOLD_ENGAGEMENT_RATE, CO.TOT_COUPONS_DISTRIBUTED, 
CO.TOT_COUPONS_REDEEMED, CO.COUPON_REDEMPTION_RATE, CO.UNIQUE_REDEEMERS_HOUSEHOLDS_COUNT, 
CA.SINGLE_CAMPAIGN_HOUSEHOLDS_COUNT, CA.MULTIPLE_CAMPAIGN_HOUSEHOLDS_COUNT, CA.SINGLE_CAMPAIGN_ENGAGEMENT_RATE,
CA.MULTIPLE_CAMPAIGN_ENGAGEMENT_RATE
FROM CAMPAIGN_KPI AS CA 
INNER JOIN COUPON_KPI AS CO ON CA.CAMPAIGN = CO.CAMPAIGN;


-- IV. PRODUCT KPIS:

SELECT * FROM PRODUCT_RAW LIMIT 20;
SELECT * FROM TRANSACTION_NEW;

SELECT COUNT(DISTINCT PRODUCT_ID), COUNT(PRODUCT_ID) FROM PRODUCT_RAW;
SELECT COUNT(DISTINCT MANUFACTURER), COUNT(MANUFACTURER) FROM PRODUCT_RAW;
SELECT COUNT(DISTINCT BASKET_ID), COUNT(BASKET_ID) FROM TRANSACTION_NEW;

-- 1. Total Number of Unique Products:

SELECT COUNT(DISTINCT PRODUCT_ID) AS TOT_PRODUCTS
FROM PRODUCT_RAW;    -- 92353

-- 2. Total Number of Manufacturers:

SELECT COUNT(DISTINCT MANUFACTURER) AS TOTAL_MANUFACTURERS 
FROM PRODUCT_RAW;   -- 6476

-- 3. Total Departments:

SELECT COUNT(DISTINCT DEPARTMENT) AS TOTAL_DEPARTMENTS 
FROM PRODUCT_RAW;   -- 44

-- 4. Number of Commodities:

SELECT COUNT(DISTINCT COMMODITY_DESC) AS TOTAL_COMMODITIES 
FROM PRODUCT_RAW;   -- 308

-- 5. Product distribution:
SELECT BRAND, MANUFACTURER, DEPARTMENT, COMMODITY_DESC, SUB_COMMODITY_DESC, 
COUNT(DISTINCT PRODUCT_ID) AS TOT_PRODUCTS
FROM PRODUCT_RAW
GROUP BY 1,2,3,4,5
ORDER BY 1;

-- 6. Manufacturer distribution: Analyze the distribution of products across different manufacturers (in the Product table).

SELECT MANUFACTURER, COUNT(PRODUCT_ID) AS TOT_PRODUCTS
FROM PRODUCT_RAW
GROUP BY 1
ORDER BY 2 DESC;

SELECT MANUFACTURER, 
COUNT(DISTINCT PRODUCT_ID) AS TOT_PRODUCTS,
COUNT(DISTINCT DEPARTMENT) AS TOT_DEPARTMENTS,
COUNT(DISTINCT COMMODITY_DESC) AS TOT_COMMODITIES,
COUNT(DISTINCT SUB_COMMODITY_DESC) AS TOT_SUB_COMMODITIES
FROM PRODUCT_RAW
GROUP BY 1
ORDER BY 2 DESC;

-- 5. Sales value: Calculate the total sales value for each product (in the Transaction_data table) to identify top-selling products.

SELECT P.PRODUCT_ID, P.COMMODITY_DESC, P.SUB_COMMODITY_DESC, P.DEPARTMENT,
SUM(T.QUANTITY) AS TOT_QUANTITY_SOLD, SUM(T.SALES_VALUE) AS TOT_SALES_AMOUNT
FROM TRANSACTION_NEW AS T
LEFT OUTER JOIN PRODUCT_RAW AS P ON T.PRODUCT_ID = P.PRODUCT_ID
GROUP BY 1,2,3,4
ORDER BY 5 DESC;

-- 7. Department-wise sales: Measure the sales value by department (in the Product table) to understand which departments contribute most to revenue.

SELECT P.DEPARTMENT, COUNT(DISTINCT P.PRODUCT_ID) AS TOT_UNIQUE_PRODUCTS,
SUM(T.QUANTITY) AS TOT_QUANTITY_SOLD, SUM(T.SALES_VALUE) AS TOT_SALES_AMOUNT
FROM TRANSACTION_NEW AS T
LEFT OUTER JOIN PRODUCT_RAW AS P ON T.PRODUCT_ID = P.PRODUCT_ID
GROUP BY 1
ORDER BY 2 DESC;

-- 8. Brand-wise sales: Calculate the sales value for each brand (in the Product table) to identify top-selling brands.

SELECT P.BRAND, COUNT(DISTINCT P.DEPARTMENT) AS TOT_UNIQUE_DEPARTMENTS,
COUNT(DISTINCT P.PRODUCT_ID) AS TOT_UNIQUE_PRODUCTS,
SUM(T.QUANTITY) AS TOT_QUANTITY_SOLD, SUM(T.SALES_VALUE) AS TOT_SALES_AMOUNT
FROM TRANSACTION_NEW AS T
LEFT OUTER JOIN PRODUCT_RAW AS P ON T.PRODUCT_ID = P.PRODUCT_ID
GROUP BY 1
ORDER BY 3 DESC;

-- 9. Commodity & Sub-Commodity wise sales:

SELECT P.COMMODITY_DESC, P.SUB_COMMODITY_DESC,
COUNT(DISTINCT P.PRODUCT_ID) AS TOT_UNIQUE_PRODUCTS,
SUM(T.QUANTITY) AS TOT_QUANTITY_SOLD, SUM(T.SALES_VALUE) AS TOT_SALES_AMOUNT
FROM TRANSACTION_NEW AS T
LEFT OUTER JOIN PRODUCT_RAW AS P ON T.PRODUCT_ID = P.PRODUCT_ID
GROUP BY 1,2
ORDER BY 4 DESC;

-- PRODUCT KPI

SELECT P.PRODUCT_ID, P.COMMODITY_DESC, P.SUB_COMMODITY_DESC, P.DEPARTMENT, P.BRAND,
COUNT(T.BASKET_ID) TOT_BASKETS,
COUNT(DISTINCT T.HOUSEHOLD_KEY) AS TOTAL_UNIQUE_BUYERS,
COUNT(DISTINCT T.STORE_ID) AS TOT_STORES,
SUM(T.QUANTITY) AS TOT_SOLD_QUANTITY,
SUM(T.SALES_VALUE) AS TOT_SALES_AMOUNT,
SUM(ABS(T.RETAIL_DISC)) AS TOT_RETAIL_DISC,
SUM(ABS(T.COUPON_DISC)) AS TOT_COUPON_DISC,
SUM(ABS(T.COUPON_MATCH_DISC)) AS TOT_COUPON_MATCH_DISC,
SUM(ABS(T.RETAIL_DISC) + ABS(T.COUPON_DISC) + ABS(T.COUPON_MATCH_DISC)) AS TOT_DISCOUNT,
ROUND(SUM(ABS(T.RETAIL_DISC) + ABS(T.COUPON_DISC) + ABS(T.COUPON_MATCH_DISC)) / NULLIF(SUM(T.SALES_VALUE), 0) * 100, 2) AS TOT_DISCOUNT_PERC,
SUM(T.SALES_VALUE + T.RETAIL_DISC + T.COUPON_DISC + T.COUPON_MATCH_DISC) AS TOT_NET_SALES_VALUE
FROM TRANSACTION_NEW AS T
LEFT OUTER JOIN PRODUCT_RAW AS P ON T.PRODUCT_ID = P.PRODUCT_ID
GROUP BY 1,2,3,4,5
ORDER BY 1,2,3,4,5;


-- V. TRANSACTION KPIS:

SELECT * FROM TRANSACTION_NEW LIMIT 10;

SELECT  TRANS_TIME_FMTD, DATE, BASKET_ID FROM TRANSACTION_NEW;
SELECT COUNT(DISTINCT TRANS_TIME_FMTD), COUNT(TRANS_TIME_FMTD),
COUNT(DISTINCT BASKET_ID), COUNT(BASKET_ID) FROM TRANSACTION_NEW;

SELECT DATE,
COUNT(DISTINCT HOUSEHOLD_KEY), COUNT(HOUSEHOLD_KEY),
COUNT(DISTINCT BASKET_ID), COUNT(BASKET_ID),
COUNT(DISTINCT TRANS_TIME_FMTD), COUNT(TRANS_TIME_FMTD),
COUNT(DISTINCT BASKET_ID), COUNT(BASKET_ID),
COUNT(DISTINCT DATE), COUNT(DATE),
COUNT(DISTINCT PRODUCT_ID), COUNT(PRODUCT_ID)
FROM TRANSACTION_NEW
GROUP BY 1;

-- 1. Transaction-Level (Baskets) KPIs: 

SELECT COUNT(DISTINCT BASKET_ID) AS TOT_TRANSACTIONS,
SUM(SALES_VALUE) AS TOT_SALES_VALUE,
ROUND(SUM(QUANTITY) / COUNT(DISTINCT BASKET_ID), 2) AS AVG_QUANTITY_PER_TRANSACTION,
ROUND(SUM(SALES_VALUE) / COUNT(DISTINCT BASKET_ID), 2) AS AVG_SALES_VALUE_PER_TRANSACTION 
FROM TRANSACTION_NEW; 

-- 2. Customer (Household) KPIs: 

SELECT COUNT(DISTINCT HOUSEHOLD_KEY) AS TOT_HOUSEHOLDS_MAKING_TRANS,
ROUND(SUM(QUANTITY) / COUNT(DISTINCT HOUSEHOLD_KEY), 2) AS AVG_PRODUCTS_SOLD_PER_HOUSEHOLD,
ROUND(SUM(SALES_VALUE) / COUNT(DISTINCT HOUSEHOLD_KEY), 2) AS AVG_SALES_VALUE_PER_HOUSEHOLD
FROM TRANSACTION_NEW;   -- 2494

-- 3. Store Performance KPIs:

SELECT COUNT(DISTINCT STORE_ID) AS TOT_UNIQUE_STORES,
ROUND(SUM(QUANTITY) / COUNT(DISTINCT STORE_ID), 2) AS AVG_PRODUCTS_SOLD_PER_STORE,
ROUND(SUM(SALES_VALUE) / COUNT(DISTINCT STORE_ID), 2) AS AVG_SALES_PER_STORE
FROM TRANSACTION_NEW;

-- 4. Product-Level KPIs:

SELECT COUNT(DISTINCT PRODUCT_ID) AS TOT_UNIQUE_PRODUCTS_SOLD,
ROUND(SUM(QUANTITY) / COUNT(DISTINCT PRODUCT_ID), 2) AS AVG_QUANTITY_PER_PRODUCT,
ROUND(SUM(SALES_VALUE) / COUNT(DISTINCT PRODUCT_ID), 2) AS AVG_SALES_VALUE_PER_PRODUCT
FROM TRANSACTION_NEW;

-- 5. Sales Performance by Hour:

SELECT HOUR(TRANS_TIME_FMTD) AS TRANSACTION_HOUR, SUM(SALES_VALUE) AS SALES_BY_HOUR
FROM TRANSACTION_NEW
GROUP BY 1
ORDER BY 2 DESC;

-- 6. Peak Transaction Hour:

SELECT HOUR(TRANS_TIME_FMTD) AS PEAK_HOUR, COUNT(BASKET_ID) AS TOTAL_TRANSACTIONS
FROM TRANSACTION_NEW
GROUP BY 1
ORDER BY 2 DESC;

-- 7. Daily Sales Trends:

SELECT DATE, SUM(SALES_VALUE) AS DAILY_SALES
FROM TRANSACTION_NEW
GROUP BY 1
ORDER BY 1;

-- 8. Average transaction value: Calculate the average sales value per transaction to understand customer spending patterns.

SELECT HOUSEHOLD_KEY, AVG(SALES_VALUE) AS AVG_SALES_VALUE
FROM TRANSACTION_NEW
GROUP BY 1
ORDER BY 2 DESC;

-- 9. Quantity sold: Measure the total quantity sold (in the Transaction_data table) to understand product demand.

SELECT PRODUCT_ID, SUM(QUANTITY) AS TOT_QUANTITY_SOLD
FROM TRANSACTION_NEW
GROUP BY 1
ORDER BY 2 DESC;

-- 10. Discounts: Analyze the amount and impact of discounts (RETAIL_DISC, COUPON_DISC, COUPON_MATCH_DISC) on sales value.

SELECT BASKET_ID, SUM(SALES_VALUE) AS TOT_SALES_VALUE, 
SUM(ABS(RETAIL_DISC)) AS TOT_RETAIL_DISC,
SUM(ABS(COUPON_DISC)) AS TOT_COUPON_DISC,
SUM(ABS(COUPON_MATCH_DISC)) AS TOT_COUPON_MATCH_DISC,
SUM(ABS(RETAIL_DISC) + ABS(COUPON_DISC) + ABS(COUPON_MATCH_DISC)) AS TOT_DISCOUNT,
SUM(SALES_VALUE + RETAIL_DISC + COUPON_DISC + COUPON_MATCH_DISC) AS TOT_NET_SALES_VALUE
FROM TRANSACTION_NEW
GROUP BY 1
ORDER BY 2 DESC;

-- Overall discount impact and net sales value across all transactions
SELECT SUM(SALES_VALUE) AS TOT_SALES_VALUE, 
SUM(ABS(RETAIL_DISC)) AS TOT_RETAIL_DISC,
SUM(ABS(COUPON_DISC)) AS TOT_COUPON_DISC,
SUM(ABS(COUPON_MATCH_DISC)) AS TOT_COUPON_MATCH_DISC,
SUM(ABS(RETAIL_DISC) + ABS(COUPON_DISC) + ABS(COUPON_MATCH_DISC)) AS TOT_DISCOUNT,
SUM(SALES_VALUE + RETAIL_DISC + COUPON_DISC + COUPON_MATCH_DISC) AS TOT_NET_SALES_VALUE
FROM TRANSACTION_NEW
ORDER BY 1 DESC;

-- TRANSACTION KPI

SELECT DATE,
COUNT(DISTINCT BASKET_ID) AS UNIQUE_TRANS_COUNT,
ROUND(SUM(QUANTITY)/COUNT(DISTINCT BASKET_ID), 2) AS AVG_PRODUCTS_SOLD_PER_TRANS,
ROUND(SUM(SALES_VALUE)/COUNT(DISTINCT BASKET_ID), 2) AS AVG_SALES_VALUE_PER_TRANS,
COUNT(DISTINCT HOUSEHOLD_KEY) AS UNIQUE_HOUSEHOLD_COUNT,
ROUND(SUM(QUANTITY)/COUNT(DISTINCT HOUSEHOLD_KEY), 2) AS AVG_PRODUCTS_SOLD_PER_HOUSEHOLD,
ROUND(SUM(SALES_VALUE)/COUNT(DISTINCT HOUSEHOLD_KEY), 2) AS AVG_SALES_VALUE_PER_HOUSEHOLD,
COUNT(DISTINCT STORE_ID) AS UNIQUE_STORE_COUNT,
ROUND(SUM(QUANTITY)/COUNT(DISTINCT STORE_ID), 2) AS AVG_PRODUCTS_SOLD_PER_STORE,
ROUND(SUM(SALES_VALUE)/COUNT(DISTINCT STORE_ID), 2) AS AVG_SALES_VALUE_PER_STORE,
ROUND(SUM(QUANTITY) / COUNT(DISTINCT HOUR(TRANS_TIME_FMTD)), 2) AS AVG_PRODUCTS_SOLD_PER_HOUR,
ROUND(SUM(SALES_VALUE) / COUNT(DISTINCT HOUR(TRANS_TIME_FMTD)), 2) AS AVG_SALES_VALUE_PER_HOUR,
COUNT(DISTINCT PRODUCT_ID) AS TOT_UNIQUE_PRODUCTS_SOLD,
SUM(QUANTITY) AS TOT_SOLD_QUANTITY,
SUM(SALES_VALUE) AS TOT_SALES_AMOUNT,
SUM(ABS(RETAIL_DISC)) AS TOT_RETAIL_DISC,
SUM(ABS(COUPON_DISC)) AS TOT_COUPON_DISC,
SUM(ABS(COUPON_MATCH_DISC)) AS TOT_COUPON_MATCH_DISC,
SUM(ABS(RETAIL_DISC) + ABS(COUPON_DISC) + ABS(COUPON_MATCH_DISC)) AS TOT_DISCOUNT,
ROUND(SUM(ABS(RETAIL_DISC) + ABS(COUPON_DISC) + ABS(COUPON_MATCH_DISC)) / SUM(SALES_VALUE) * 100, 2) AS TOT_DISCOUNT_PERC,
SUM(SALES_VALUE + RETAIL_DISC + COUPON_DISC + COUPON_MATCH_DISC) AS TOT_NET_SALES_VALUE
FROM TRANSACTION_NEW
GROUP BY 1
ORDER BY 1;

SELECT DATE, COUNT(TRANS_TIME_FMTD), COUNT(DISTINCT TRANS_TIME_FMTD), SUM(QUANTITY),
ROUND(SUM(QUANTITY) / COUNT(DISTINCT HOUR(TRANS_TIME_FMTD)), 2),
ROUND(SUM(QUANTITY)/COUNT(DISTINCT TRANS_TIME_FMTD), 2) AS AVG_PRODUCTS_SOLD_PER_HOUR,
ROUND(SUM(QUANTITY)/COUNT(TRANS_TIME_FMTD), 2),
ROUND(SUM(SALES_VALUE)/COUNT(DISTINCT TRANS_TIME_FMTD), 2) AS AVG_SALES_VALUE_PER_HOUR
FROM TRANSACTION_NEW
GROUP BY 1;

SELECT DATE, COUNT(DISTINCT DATE), COUNT(DATE), COUNT(DISTINCT HOUR(TRANS_TIME_FMTD)), COUNT(HOUR(TRANS_TIME_FMTD)),
ROUND(SUM(QUANTITY) / COUNT( DATE), 2),
ROUND(SUM(QUANTITY) / COUNT(DISTINCT DATE), 2) AS AVG_PRODUCTS_SOLD_PER_DAY,
ROUND(SUM(QUANTITY) / COUNT(DISTINCT HOUR(TRANS_TIME_FMTD)), 2) AS AVG_PRODUCTS_SOLD_PER_HOUR,
ROUND(SUM(SALES_VALUE) / COUNT(DISTINCT DATE), 2) AS AVG_SALES_VALUE_PER_DAY,
ROUND(SUM(SALES_VALUE) / COUNT(DISTINCT HOUR(TRANS_TIME_FMTD)), 2) AS AVG_SALES_VALUE_PER_HOUR
FROM TRANSACTION_NEW
GROUP BY 1;

-----------------------------------------------------------------------------------------------------------------

/* AUTOMATING KPI TABLES CREATION USING STORED PROCEDURES AND TASKS */

-- HOUSEHOLD_KPI
CREATE OR REPLACE PROCEDURE CREATE_OR_REPLACE_HOUSEHOLD_KPI()
RETURNS STRING
LANGUAGE SQL
AS
$$
CREATE OR REPLACE TABLE HOUSEHOLD_KPI AS

SELECT T.HOUSEHOLD_KEY, D.AGE_DESC, D.MARITAL_STATUS_CODE, D.INCOME_DESC, D.HOMEOWNER_DESC, 
D.HOUSEHOLD_SIZE_DESC, D.HH_COMP_DESC, D.KID_CATEGORY_DESC, 
COUNT(DISTINCT T.BASKET_ID) AS TOT_BASKET_OR_TXN_COUNT,
AVG(T.QUANTITY) AS AVG_BASKET_SIZE,
SUM(T.QUANTITY) AS TOT_BASKET_SIZE,
MAX(T.DATE) - MIN(T.DATE) AS CUSTOMER_TENURE,
AVG(T.SALES_VALUE) AS AVG_SALES_AMOUNT,
SUM(T.SALES_VALUE) AS TOT_SALES_AMOUNT,
AVG(ABS(T.RETAIL_DISC)) AS AVG_RETAIL_DISC, 
AVG(ABS(T.COUPON_DISC)) AS AVG_COUPON_DISC, 
AVG(ABS(T.COUPON_MATCH_DISC)) AS AVG_COUPON_MATCH_DISC,
SUM(ABS(T.RETAIL_DISC)) AS TOT_RETAIL_DISC,
SUM(ABS(T.COUPON_DISC)) AS TOT_COUPON_DISC,
SUM(ABS(T.COUPON_MATCH_DISC)) AS TOT_COUPON_MATCH_DISC,
AVG(ABS(T.RETAIL_DISC) + ABS(T.COUPON_DISC) + ABS(T.COUPON_MATCH_DISC)) AS OVERALL_AVG_DISCOUNT,
SUM(ABS(T.RETAIL_DISC) + ABS(T.COUPON_DISC) + ABS(T.COUPON_MATCH_DISC)) AS TOT_DISCOUNT,
ROUND(SUM(ABS(T.RETAIL_DISC) + ABS(T.COUPON_DISC) + ABS(T.COUPON_MATCH_DISC)) / NULLIF(SUM(T.SALES_VALUE), 0) * 100, 2) AS TOT_DISCOUNT_PERC,
AVG(T.SALES_VALUE + T.RETAIL_DISC + T.COUPON_DISC + T.COUPON_MATCH_DISC) AS AVG_NET_SALES_AMOUNT,
SUM(T.SALES_VALUE + T.RETAIL_DISC + T.COUPON_DISC + T.COUPON_MATCH_DISC) AS TOT_NET_SALES_AMOUNT
FROM TRANSACTION_NEW AS T
LEFT OUTER JOIN DEMOGRAPHIC_RAW AS D ON T.HOUSEHOLD_KEY = D.HOUSEHOLD_KEY
GROUP BY 1,2,3,4,5,6,7,8
ORDER BY 1;
$$;

-- CAMPAIGN_KPI
CREATE OR REPLACE PROCEDURE CREATE_OR_REPLACE_CAMPAIGN_KPI()
RETURNS STRING
LANGUAGE SQL
AS
$$
CREATE OR REPLACE TABLE CAMPAIGN_KPI AS 

WITH CAMPAIGN_PARTICIPATION AS (
    SELECT HOUSEHOLD_KEY, CAMPAIGN, COUNT(CAMPAIGN) OVER (PARTITION BY HOUSEHOLD_KEY) AS CAMPAIGN_COUNT
    FROM CAMPAIGN_RAW
)
SELECT C.CAMPAIGN, C.DESCRIPTION, CD.START_DATE AS CAMPAIGN_START_DATE, 
CD.END_DATE AS CAMPAIGN_END_DATE, CD.CAMPAIGN_DURATION,
COUNT(DISTINCT C.HOUSEHOLD_KEY) AS TOT_HOUSEHOLDS,
ROUND((COUNT(DISTINCT C.HOUSEHOLD_KEY)) / (SELECT COUNT(DISTINCT HOUSEHOLD_KEY) FROM CAMPAIGN_RAW) * 100, 2) AS HOUSEHOLD_ENGAGEMENT_RATE,
SUM(CASE WHEN CP.CAMPAIGN_COUNT = 1 THEN 1 ELSE 0 END) AS SINGLE_CAMPAIGN_HOUSEHOLDS_COUNT,
SUM(CASE WHEN CP.CAMPAIGN_COUNT > 1 THEN 1 ELSE 0 END) AS MULTIPLE_CAMPAIGN_HOUSEHOLDS_COUNT,
ROUND(SUM(CASE WHEN CP.CAMPAIGN_COUNT = 1 THEN 1 ELSE 0 END) / COUNT(DISTINCT C.HOUSEHOLD_KEY) * 100,2) AS SINGLE_CAMPAIGN_ENGAGEMENT_RATE,
ROUND(SUM(CASE WHEN CP.CAMPAIGN_COUNT > 1 THEN 1 ELSE 0 END) / COUNT(DISTINCT C.HOUSEHOLD_KEY) * 100,2) AS MULTIPLE_CAMPAIGN_ENGAGEMENT_RATE

FROM CAMPAIGN_RAW AS C
LEFT OUTER JOIN CAMPAIGN_DESC_NEW AS CD ON C.CAMPAIGN = CD.CAMPAIGN
LEFT OUTER JOIN CAMPAIGN_PARTICIPATION AS CP ON C.HOUSEHOLD_KEY = CP.HOUSEHOLD_KEY AND C.CAMPAIGN = CP.CAMPAIGN
GROUP BY 1,2,3,4,5
ORDER BY 1;
$$;

-- COUPON_KPI
CREATE OR REPLACE PROCEDURE CREATE_OR_REPLACE_COUPON_KPI()
RETURNS STRING
LANGUAGE SQL
AS
$$
CREATE OR REPLACE TABLE COUPON_KPI AS

SELECT CO.CAMPAIGN, -- COR.DATE AS COUPON_REDEMPTION_DATE,
COUNT(DISTINCT CO.PRODUCT_ID) AS DISTINCT_PRODUCT_COUNT,
COUNT(DISTINCT CO.COUPON_UPC) AS TOT_COUPONS_DISTRIBUTED,
COUNT(DISTINCT COR.COUPON_UPC) AS TOT_COUPONS_REDEEMED,
ROUND(COUNT(DISTINCT COR.COUPON_UPC) / COUNT(DISTINCT CO.COUPON_UPC) * 100, 2) AS COUPON_REDEMPTION_RATE,
COUNT(DISTINCT COR.HOUSEHOLD_KEY) AS UNIQUE_REDEEMERS_HOUSEHOLDS_COUNT
FROM COUPON_RAW AS CO
LEFT OUTER JOIN COUPON_REDEMPT_NEW AS COR ON CO.COUPON_UPC = COR.COUPON_UPC AND CO.CAMPAIGN = COR.CAMPAIGN
GROUP BY 1
ORDER BY 1;
$$;

-- PRODUCT KPI
CREATE OR REPLACE PROCEDURE CREATE_OR_REPLACE_PRODUCT_KPI()
RETURNS STRING
LANGUAGE SQL
AS
$$
CREATE OR REPLACE TABLE PRODUCT_KPI AS 

SELECT P.PRODUCT_ID, P.COMMODITY_DESC, P.SUB_COMMODITY_DESC, P.DEPARTMENT, P.BRAND,
COUNT(T.BASKET_ID) TOT_BASKETS,
COUNT(DISTINCT T.HOUSEHOLD_KEY) AS TOTAL_UNIQUE_BUYERS,
COUNT(DISTINCT T.STORE_ID) AS TOT_STORES,
SUM(T.QUANTITY) AS TOT_SOLD_QUANTITY,
SUM(T.SALES_VALUE) AS TOT_SALES_AMOUNT,
SUM(ABS(T.RETAIL_DISC)) AS TOT_RETAIL_DISC,
SUM(ABS(T.COUPON_DISC)) AS TOT_COUPON_DISC,
SUM(ABS(T.COUPON_MATCH_DISC)) AS TOT_COUPON_MATCH_DISC,
SUM(ABS(T.RETAIL_DISC) + ABS(T.COUPON_DISC) + ABS(T.COUPON_MATCH_DISC)) AS TOT_DISCOUNT,
ROUND(SUM(ABS(T.RETAIL_DISC) + ABS(T.COUPON_DISC) + ABS(T.COUPON_MATCH_DISC)) / NULLIF(SUM(T.SALES_VALUE), 0) * 100, 2) AS TOT_DISCOUNT_PERC,
SUM(T.SALES_VALUE + T.RETAIL_DISC + T.COUPON_DISC + T.COUPON_MATCH_DISC) AS TOT_NET_SALES_VALUE
FROM TRANSACTION_NEW AS T
LEFT OUTER JOIN PRODUCT_RAW AS P ON T.PRODUCT_ID = P.PRODUCT_ID
GROUP BY 1,2,3,4,5
ORDER BY 1,2,3,4,5;
$$;

-- TRANSACTION KPI
CREATE OR REPLACE PROCEDURE CREATE_OR_REPLACE_TRANSACTION_KPI()
RETURNS STRING
LANGUAGE SQL
AS
$$
CREATE OR REPLACE TABLE TRANSACTION_KPI AS

SELECT DATE,
COUNT(DISTINCT BASKET_ID) AS UNIQUE_TRANS_COUNT,
ROUND(SUM(QUANTITY)/COUNT(DISTINCT BASKET_ID), 2) AS AVG_PRODUCTS_SOLD_PER_TRANS,
ROUND(SUM(SALES_VALUE)/COUNT(DISTINCT BASKET_ID), 2) AS AVG_SALES_VALUE_PER_TRANS,
COUNT(DISTINCT HOUSEHOLD_KEY) AS UNIQUE_HOUSEHOLD_COUNT,
ROUND(SUM(QUANTITY)/COUNT(DISTINCT HOUSEHOLD_KEY), 2) AS AVG_PRODUCTS_SOLD_PER_HOUSEHOLD,
ROUND(SUM(SALES_VALUE)/COUNT(DISTINCT HOUSEHOLD_KEY), 2) AS AVG_SALES_VALUE_PER_HOUSEHOLD,
COUNT(DISTINCT STORE_ID) AS UNIQUE_STORE_COUNT,
ROUND(SUM(QUANTITY)/COUNT(DISTINCT STORE_ID), 2) AS AVG_PRODUCTS_SOLD_PER_STORE,
ROUND(SUM(SALES_VALUE)/COUNT(DISTINCT STORE_ID), 2) AS AVG_SALES_VALUE_PER_STORE,
ROUND(SUM(QUANTITY) / COUNT(DISTINCT HOUR(TRANS_TIME_FMTD)), 2) AS AVG_PRODUCTS_SOLD_PER_HOUR,
ROUND(SUM(SALES_VALUE) / COUNT(DISTINCT HOUR(TRANS_TIME_FMTD)), 2) AS AVG_SALES_VALUE_PER_HOUR,
COUNT(DISTINCT PRODUCT_ID) AS TOT_UNIQUE_PRODUCTS_SOLD,
SUM(QUANTITY) AS TOT_SOLD_QUANTITY,
SUM(SALES_VALUE) AS TOT_SALES_AMOUNT,
SUM(ABS(RETAIL_DISC)) AS TOT_RETAIL_DISC,
SUM(ABS(COUPON_DISC)) AS TOT_COUPON_DISC,
SUM(ABS(COUPON_MATCH_DISC)) AS TOT_COUPON_MATCH_DISC,
SUM(ABS(RETAIL_DISC) + ABS(COUPON_DISC) + ABS(COUPON_MATCH_DISC)) AS TOT_DISCOUNT,
ROUND(SUM(ABS(RETAIL_DISC) + ABS(COUPON_DISC) + ABS(COUPON_MATCH_DISC)) / SUM(SALES_VALUE) * 100, 2) AS TOT_DISCOUNT_PERC,
SUM(SALES_VALUE + RETAIL_DISC + COUPON_DISC + COUPON_MATCH_DISC) AS TOT_NET_SALES_VALUE
FROM TRANSACTION_NEW
GROUP BY 1
ORDER BY 1;
$$;

SHOW PROCEDURES; 

-- We can execute the above procedures manually by running the following code. Whenever we invoke these procedures, the code within them will automatically be executed.

CALL CREATE_OR_REPLACE_HOUSEHOLD_KPI();
CALL CREATE_OR_REPLACE_CAMPAIGN_KPI();
CALL CREATE_OR_REPLACE_COUPON_KPI();
CALL CREATE_OR_REPLACE_PRODUCT_KPI();
CALL CREATE_OR_REPLACE_TRANSACTION_KPI();

-- Instead, to automate the process, we assign these CALL operations to five distinct tasks for each procedure, scheduling them at different times to prevent overlap during code execution.

CREATE OR REPLACE TASK HOUSEHOLD_KPI
WAREHOUSE = COMPUTE_WH
SCHEDULE =  'USING CRON 20 10 23 4 * UTC'  -- At 10:20 AM (IST 3:50 PM), on day 23 of the month, only in April UTC
AS CALL CREATE_OR_REPLACE_HOUSEHOLD_KPI();
  
CREATE OR REPLACE TASK CAMPAIGN_KPI
WAREHOUSE = COMPUTE_WH
SCHEDULE =  'USING CRON 21 10 23 4 * UTC'  
AS CALL CREATE_OR_REPLACE_CAMPAIGN_KPI();

CREATE OR REPLACE TASK COUPON_KPI
WAREHOUSE = COMPUTE_WH
SCHEDULE =  'USING CRON 22 10 23 4 * UTC'  
AS CALL CREATE_OR_REPLACE_COUPON_KPI();

CREATE OR REPLACE TASK PRODUCT_KPI
WAREHOUSE = COMPUTE_WH
SCHEDULE =  'USING CRON 23 10 23 4 * UTC'  
AS CALL CREATE_OR_REPLACE_PRODUCT_KPI();

CREATE OR REPLACE TASK TRANSACTION_KPI
WAREHOUSE = COMPUTE_WH
SCHEDULE =  'USING CRON 24 10 23 4 * UTC'  
AS CALL CREATE_OR_REPLACE_TRANSACTION_KPI();

SHOW TASKS;

ALTER TASK HOUSEHOLD_KPI RESUME;
ALTER TASK CAMPAIGN_KPI RESUME;
ALTER TASK COUPON_KPI RESUME;
ALTER TASK PRODUCT_KPI RESUME;
ALTER TASK TRANSACTION_KPI RESUME;

SELECT * FROM HOUSEHOLD_KPI;  -- 2500 rows
SELECT * FROM CAMPAIGN_KPI;  -- 30 rows
SELECT * FROM COUPON_KPI;  -- 30 rows
SELECT * FROM PRODUCT_KPI;  -- 92,339 rows
SELECT * FROM TRANSACTION_KPI;  -- 711 rows
-- 176 rows before updating new data  
-- 353 rows after updating new data

ALTER TASK HOUSEHOLD_KPI SUSPEND;
ALTER TASK CAMPAIGN_KPI SUSPEND; 
ALTER TASK COUPON_KPI SUSPEND;
ALTER TASK PRODUCT_KPI SUSPEND; 
ALTER TASK TRANSACTION_KPI SUSPEND;












